# 代码规范
参考凹凸实验室代码规范：  https://guide.aotu.io/

# 字符实体
**什么是字符实体：**
HTML 实体是一段以连字号（&）开头、以分号（;）结尾的文本（字符串）：
实体常常用于显示保留字符（这些字符会被解析为 HTML 代码）和不可见的字符（如“不换行空格”）；你也可以用实体来代替其他难以用标准键盘键入的字符；

**常见的字符实体：**
[HTML 字符实体 (w3school.com.cn)](https://www.w3school.com.cn/html/html_entities.asp)

# 认识URL
**URL 代表着是统一资源定位符（Uniform Resource Locator）**
**通俗点说：** URL 无非就是一个给定的独特资源在 Web 上的地址。理论上说，每个有效的 URL 都指向一个唯一的资源；这个资源可以是一个 HTML 页面，一个 CSS 文档，一幅图像，等等；
## URL的格式
**URL的标准格式如下**：
\[协议类型\]://\[服务器地址\]:\[端口号\]/\[文件路径\]\[文件名\]?\[查询\]#\[片段ID\]
**和URI的区别:**
- URI = Uniform Resource Identifier 统一资源标志符，用于标识 Web 技术使用的逻辑或物理资源。；
- URL = Uniform Resource Locator 统一资源定位符，俗称网络地址，相当于网络中的门牌号；
URI在某一个规则下能把一个资源独一无二的识别出来。
URL作为一个网络Web资源的地址，可以唯一将一个资源识别出来，所以URL是一个URI；
所以URL是URI的一个子集；但是URI并不一定是URL
locators are also identifiers, so every URL is also a URI, but there are URIs which are not URLs.
# 元素的语义化
元素的语义化：用正确的元素做正确的事情。

理论上来说，所有的HTML元素，我们都能实现相同的事情；但是标签语义化有许多好处：
- 方便代码维护；
- 减少让开发者之间的沟通成本；
- 能让语音合成工具正确识别网页元素的用途，以便作出正确的反应；
- 有利于SEO
- ......

# 什么是SEO
搜索引擎优化（英语：search engine optimization，缩写为SEO）是通过了解搜索引擎的运作规则来调整网站， 以及提高网站在有关搜索引擎内排名的方式。

# 认识字符编码

字符编码的发展历史： https://www.jianshu.com/p/899e749be47c

## CSS样式的字符编码
**在样式表中有多种方法去声明字符编码，浏览器会按照以下顺序尝试下边的方法（一旦找到就停止并得出结果）：**
1. 文件的开头的 Unicode byte-order（字节顺序标记） 字符值。 https://en.wikipedia.org/wiki/Byte_order_mark
2. 由Content-Type：HTTP header 中的 charset 属性给出的值或用于提供样式表的协议中的等效值。
3. CSS @规则 @charset。
4. 使用参考文档定义的字符编码： 元素的 charset 属性。  该方法在 HTML5 标准中已废除，无法使用。
5. 假设文档是 UTF-8。
开发中推荐在CSS的开头编写@charset指定编码：

# 认识进制
**认识进制：**
- 维基百科：进位制是一种记数方式，亦称进位计数法或位值计数法。
- 通俗理解：当数字达到某个值时，进一位(比如从1位变成2位)。
**按照进制的概念，来理解一下十进制：** 当数字到9的时候，用一位已经表示不了了，那么就进一位变成2位。
**二进制**：当数字到1的时候，用一位已经表示不了了，那么就进一位。
**八进制**：当数字到7的时候，用一位已经表示不了了，那么就进一位。
**十六进制**：等等，用一位如何表示十六个数字呢？a(10)、b(11)、c(12) 、 d(13) 、 e(14) 、 f(15)

**表示二进制、八进制、十六进制：**
- 二进制（0b开头, binary）：其中的数字由0、1组成，可以回顾之前学习过的机器语言。
- 八进制（0o开头, Octonary）：其中的数字由0~7组成。
- 十六进制（0x开头, hexadecimal）：其中的数字由0~9和字母a-f组成（大小写都可以）
### 进制之间的转换
- 十进制转其他进制：整除, 取余数
- 二进制转八进制：三位转成一位八进制
- 二进制转十六进制：四位转成一位十六进制

# 浏览器前缀
有时候可能会看到有些CSS属性名前面带有：-o-、-xv-、-ms-、mso-、-moz-、-webkit-
官方文档专业术语叫做：vendor-specific extensions（供应商特定扩展）
为什么需要浏览器前缀了？
CSS属性刚开始并没有成为标准，浏览器为了防止后续会修改名字给新的属性添加了浏览器前缀；
**上述前缀叫做浏览器私有前缀，只有对应的浏览器才能解析使用**
- -o-、-xv-：Opera等
- -ms-、mso-：IE等
- -moz-：Firefox等
- -webkit-：Safari、Chrome等
**注意：不需要手动添加，后面学习了模块化打包工具会自动添加浏览器前缀**

# BFC
## FC – Formatting Context
什么是FC呢？
FC的全称是Formatting Context，元素在标准流里面都是属于一个FC的；
**块级元素的布局属于Block Formatting Context（BFC）**
也就是block level box都是在BFC中布局的；
**行内级元素的布局属于Inline Formatting Context（IFC）**
而inline level box都是在IFC中布局的；

## BFC – Block Formatting Context
**MDN上有整理出在哪些具体的情况下会创建BFC：**
- 根元素（\<html\>）
- 浮动元素（元素的 float 不是 none）
- 绝对定位元素（元素的 position 为 absolute 或 fixed）
- 行内块元素（元素的 display 为 inline-block）
- 表格单元格（元素的 display 为 table-cell，HTML表格单元格默认为该值），表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）
- 匿名表格单元格元素（元素的 display 为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、 row、tbody、thead、tfoot 的默认属性）或 inline-table）
- overflow 计算值(Computed)不为 visible 的块元素
- 弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）
- 网格元素（display 为 grid 或 inline-grid 元素的直接子元素）
- display 值为 flow-root 的元素
## BFC有什么作用呢？
**简单概况如下：**
- 在BFC中，box会在垂直方向上一个挨着一个的排布；
- 垂直方向的间距由margin属性决定；
- 在同一个BFC中，相邻两个box之间的margin会折叠（collapse）；
- 在BFC中，每个元素的左边缘是紧挨着包含块的左边缘的；
**那么这个东西有什么用呢？**
- 解决margin的折叠问题；
- 解决浮动高度塌陷问题；
### BFC的作用一：解决折叠问题（权威）
在同一个BFC中，相邻两个box之间的margin会折叠（collapse）
官方文档明确的有说: The vertical distance between two sibling boxes is determined by the 'margin' properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.
那么如果我们让两个box是不同的BFC呢？那么就可以解决折叠问题。
### BFC的作用二：解决浮动高度塌陷（权威）
网上有很多说法，BFC可以解决浮动高度塌陷，可以实现清除浮动的效果。但是从来没有给出过BFC可以解决高度塌陷的原理或者权威的文档说明；他们也压根没有办法解释，为什么可以解决浮动高度的塌陷问题，但是不能解决绝对定位元素的高度塌陷问题呢？
**事实上，BFC解决高度塌陷需要满足两个条件**
- 浮动元素的父元素触发BFC，形成独立的块级格式化上下文（Block Formatting Context）；
- 浮动元素的父元素的高度是auto的；
**BFC的高度是auto的情况下，是如下方法计算高度的**
1. 如果只有inline-level，是行高的顶部和底部的距离；
2. 如果有block-level，是由最底层的块上边缘和最底层 块盒子的下边缘之间的距离
3. 如果有绝对定位元素，将被忽略；
4. 如果有浮动元素，那么会增加高度以包括这些浮动元 素的下边缘

# 媒体查询
媒体查询是一种提供给开发者针对不同设备需求进行定制化开发的一个接口。
你可以根据设备的类型（比如屏幕设备、打印机设备）或者特定的特性（比如屏幕的宽度）来修改你的页面。
**媒体查询的使用方式主要有三种：**
- 方式一：通过@media和@import使用不同的CSS规则（常用）；
  ```css
  <style>
	  @import url(./css/miniScreen.css) (max-width: 600px);
  </style>
  ```
- 方式二：使用media属性为\<style\>, \<link\>, \<source\>和其他HTML元素指定特定的媒体类型；
  ```css
  <link rel="stylesheet" media="(max-width: 600px)" herf="./css/miniScreen.css" >
  ```
- 方式三：使用Window.matchMedia() 和MediaQueryList.addListener() 方法来测试和监控媒体状态；
比较常用的是通过@media来使用不同的CSS规则，目前掌握这个即可；

## 媒体查询 - 媒体类型（Media types）
在使用媒体查询时，你必须指定要使用的媒体类型;媒体类型是可选的，并且会（隐式地）应用 all 类型。
**常见的媒体类型值如下：**
- all：适用于所有设备。
- print：适用于在打印预览模式下在屏幕上查看的分页材料和文档。
- screen（掌握）：主要用于屏幕。
- speech：主要用于语音合成器。
**被废弃的媒体类型：**
- CSS2.1 和 Media Queries 3 定义了一些额外的媒体类型(tty, tv, projection, handheld, braille, embossed, 以及 aural)；
- 但是他们在Media Queries 4 中已经被废弃，并且不应该被使用；
- aural类型被替换为具有相似效果的speech。
## 媒体查询 – 媒体特性（Media features）
媒体特性（Media features）描述了 浏览器、输出设备，或是预览环境的具体特征；
通常会将媒体特性描述为一个表达式；每条媒体特性表达式都必须用括号括起来；
| 特征                        | 价值                    | 最小/最大 | 描述               |
| --------------------------- | ----------------------- | --------- | ------------------ |
| 宽度width                   | 长度                    | 是的      | 渲染表面的宽度     |
| 高度height                  | 长度                    | 是的      | 渲染表面的高度     |
| 颜色color                   | 整数                    | 是的      | 每个颜色分量的位数 |
| 设备比例device-aspect-ratio | 整数/整数               | 是的      | 长宽比             |
| 设备高度device-width        | 长度                    | 是的      | 输出设备的高度     |
| 设备宽度device-height       | 长度                    | 是的      | 输出设备的宽度     |
| 方向orientation             | “portrait”或“landscape” | 不        | 屏幕方向           |
|分辨率resolution|分辨率（“ dpi”，“ dpcm”或“ dppx”）|是的|解析度|

## 媒体查询 – 逻辑操作符（logical operators）
**媒体查询的表达式最终会获得一个Boolean值，也就是真（true）或者假（false）。**
- 如果结果为真（true），那么就会生效；
- 如果结果为假（false），那么就不会生效；
**如果有多个条件，我们可以通过逻辑操作符联合复杂的媒体查询：**
- and：and 操作符用于将多个媒体查询规则组合成单条媒体查询
- not：not运算符用于否定媒体查询，如果不满足这个条件则返回true，否则返回false。
- only：only运算符仅在整个查询匹配时才用于应用样式。
- , (逗号)：逗号用于将多个媒体查询合并为一个规则。
**比如下面的媒体查询，表示：屏幕宽度大于500，小于700的时候，body背景颜色为红色；**

```css
@media screen and (min-width: 500px) and (max-width: 700px) {
	body {
		background-color: #f00;
	}
}
```

# 什么是移动端适配？
**移动互联网的快速发展，让人们已经越来越习惯于使用手机来完成大部分日常的事务。**
前端我们已经学习了大量HTML、CSS的前端开发知识，并且也进行了项目实战；这些知识也同样适用于移动端开发，但是如果想让一个页面真正适配于移动端，我们最好多了解一些移动端的知识；
**移动端开发目前主要包括三类：**
- 原生App开发（iOS、Android、RN、uniapp、Flutter等）
- 小程序开发（原生小程序、uniapp、Taro等）
- Web页面（移动端的Web页面，可以使用浏览器或者webview浏览）
**因为目前移动端设备较多，所以我们需要对其进行一些适配。**

**这里有两个概念：**
- 自适应：根据不同的设备屏幕大小来自动调整尺寸、大小；
- 响应式：会随着屏幕的实时变动而自动调整，是一种自适应；
## 认识视口viewport
**在前面我们已经简单了解过视口的概念了：**
在一个浏览器中，我们可以看到的区域就是视口（viewport）；我们说过fixed就是相对于视口来进行定位的；在PC端的页面中，我们是不需要对视口进行区分，因为我们的布局视口和视觉视口是同一个；
**但是在移动端，不太一样，你布局的视口和你可见的视口是不太一样的。**
这是因为移动端的网页窗口往往比较小，我们可能会希望一个大的网页在移动端可以完整的显示；所以在默认情况下，移动端的布局视口是大于视觉视口的；
**所以在移动端，我们可以将视口划分为三种情况：**
- 布局视口（layout viewport）
- 视觉视口（visual layout）
- 理想视口（ideal layout）
**这些概念的区分，事实上来自ppk，他也是对前端贡献比较大的一个人（特别是在移动端浏览器）**
https://www.quirksmode.org/mobile/viewports2.html

## 布局视口和视觉视口
**布局视口（layout viewport）**
默认情况下，一个在PC端的网页在移动端会如何显示呢？
第一，它会按照宽度为980px来布局一个页面的盒子和内容；
第二，为了显示可以完整的显示在页面中，对整个页面进行缩小；
**我们相对于980px布局的这个视口，称之为布局视口（layout viewport）；** 布局视口的默认宽度是980px；

**视觉视口（visual viewport）**
如果默认情况下，我们按照980px显示内容，那么右侧有一部分区域 就会无法显示，所以手机端浏览器会默认对页面进行缩放以显示到用 户的可见区域中；那么显示在可见区域的这个视口，就是视觉视口（visual viewport）
在Chrome上按shift+鼠标左键可以进行缩放。

**理想视口（ideal viewport）**
如果所有的网页都按照980px在移动端布局，那么最终页面都会被缩放显示。事实上这种方式是不利于我们进行移动的开发的，我们希望的是设置100px，那么显示的就是100px；如何做到这一点呢？通过设置理想视口（ideal viewport）；
**理想视口（ideal viewport）：**
默认情况下的layout viewport并不适合我们进行布局；我们可以对layout viewport进行宽度和缩放的设置，以满足正常在一个移动端窗口的布局；这个时候可以设置meta中的viewport；
| 值            | 可能的附加值                         | 描述                                                               |
| ------------- | ------------------------------------ | ------------------------------------------------------------------ |
| width         | 一个正整数，或者字符串 device-width  | 定义 viewport 的宽度。                                             |
| height        | 一个正整数，或者字符串 device-height | 定义 viewport 的高度。未被任何浏览器使用。                         |
| initial-scale | 一个 0.0 和 10.0 之间的正数          | 定义设备宽度与 viewport 大小之间的缩放比例。                       |
| maximum-scale | 一个 0.0 和 10.0 之间的正数          | 定义缩放的最大值，必须大于等于 minimum-scale，否则表现将不可预测。 |
| minimum-scale | 一个 0.0 和 10.0 之间的正数          | 定义缩放的最小值，必须小于等于 maximum-scale，否则表现将不可预测。 |
|user-scalable|yes 或者 no|默认为 yes，如果设置为 no，将无法缩放当前页面。浏览器可以忽略此规则；|

## 移动端适配方案
**移动端的屏幕尺寸通常是非常繁多的，很多时候我们希望在不同的屏幕尺寸上显示不同的大小；**
比如我们设置一个100x100的盒子：
- 在375px的屏幕上显示是100x100;
- 在320px的屏幕上显示是90+x90+
- 在414px的屏幕上显示是100+x100+;
其他尺寸也是类似，比如padding、margin、border、left，甚至是font-size等等；

**这个时候，我们可能可以想到一些方案来处理尺寸：**
- 方案一：百分比设置；（因为不同属性的百分比值，相对的可能是不同参照物，所以百分比往往很难统一；所以百分比在移动端适配中使用是非常少的）
- 方案二：rem单位+动态html的font-size；
- 方案三：vw单位
- 方案四：flex的弹性布局；

### 适配方案 – rem+动态html的font-size
**rem单位是相对于html元素的font-size来设置的，那么如果我们需要在不同的屏幕下有不同的尺寸，可以动态的修改html的 font-size尺寸。**
**比如如下案例：**
1. 设置一个盒子的宽度是2rem；
2. 设置不同的屏幕上html的font-size不同；

**这样在开发中，我们只需要考虑两个问题：**
- 问题一：针对不同的屏幕，设置html不同的font-size；
- 问题二：将原来要设置的尺寸，转化成rem单位；
#### rem的font-size尺寸
- **方案一：媒体查询** 可以通过媒体查询来设置不同尺寸范围内的屏幕html的font-size尺寸；
  缺点：我们需要针对不同的屏幕编写大量的媒体查询；如果动态改变尺寸，不会实时的进行更新；
- **方案二：编写js代码** 如果希望实时改变屏幕尺寸时，font-size也可以实时更改，可以通过js代码；
  方法：根据html的宽度计算出font-size的大小，并且设置到html上；监听页面的实时改变，并且重新设置font-size的大小到html上；
- **方案三：lib-flexible库** 事实上，lib-flexible库做的事情是相同的，你也可以直接引入它；

### rem的单位换算
- **方案一：手动换算**
- **方案二：less/scss函数**
- **方案三：postcss-pxtorem** (目前在前端的工程化开发中，我们可以借助于webpack的工具来完成自动的转化；)
- **方案四：VSCode插件** px to rem 的插件，在编写时自动转化；

## 适配方案 - vw
在flexible GitHub上已经有写过这样的一句话：由于viewport单位得到众多浏览器的兼容，lib-flexible这个过渡方案已经可以放弃使用，不管是现在的版本还是以前的版本，都存在一定的问题，建议大家开始使用viewport来替代此方法。
### vw和rem的对比
**rem事实上是作为一种过渡的方案，它利用的也是vw的思想。**
- 前面不管是我们自己编写的js，还是flexible的源码；
- 都是将1rem等同于设计稿的1/10，在利用1rem计算相对于整个屏幕的尺寸大小；
- 那么我们来思考，1vw不是刚好等于屏幕的1/100吗？
- 而且相对于rem还更加有优势
**vw相比于rem的优势：**
- 优势一：不需要去计算html的font-size大小，也不需要给html设置这样一个font-size；
- 优势二：不会因为设置html的font-size大小，而必须给body再设置一个font-size，防止继承；
- 优势三：因为不依赖font-size的尺寸，所以不用担心某些原因html的font-size尺寸被篡改，页面尺寸混乱；
- 优势四：vw相比于rem更加语义化，1vw刚才是1/100的viewport的大小
- 优势五：可以具备rem之前所有的优点；
**vw我们只面临一个问题，将尺寸换算成vw的单位即可；**
所以，目前相比于rem，更加推荐大家使用vw（但是理解rem依然很重要）

### vw的单位换算
- **方案一：手动换算**
- **方案二：less/scss函数**
- **方案三：postcss-pxtorem** (目前在前端的工程化开发中，我们可以借助于webpack的工具来完成自动的转化；)
- **方案四：VSCode插件** px to rem 的插件，在编写时自动转化；



# CSS预处理器
## CSS编写的痛点
CSS作为一种样式语言, 本身用来给HTML元素添加样式是没有问题的.但是目前前端项目已经越来越复杂, 不再是简简单单的几行CSS就可以搞定的, 我们需要几千行甚至上万行的CSS来完成页面的美化工作.**随着代码量的增加, 必然会造成很多的编写不便：**
- 比如大量的重复代码, 虽然可以用类来勉强管理和抽取, 但是使用起来依然不方便；
- 比如无法定义变量（当然目前已经支持）, 如果一个值被修改, 那么需要修改大量代码, 可维护性很差; (比如主题颜色)
- 比如没有专门的作用域和嵌套, 需要定义大量的id/class来保证选择器的准确性, 避免样式混淆;
- 等等一系列的问题；
**所以有一种对CSS称呼是 “面向命名编程”;**
**社区为了解决CSS面临的大量问题, 出现了一系列的CSS预处理器(CSS_preprocessor)**
- CSS 预处理器是一个能让你通过预处理器自己独有的语法来生成CSS的程序
- 市面上有很多CSS预处理器可供选择，且绝大多数CSS预处理器会增加一些原生CSS不具备的特性;
- 代码最终会转化为CSS来运行, 因为对于浏览器来说只识别CSS;
## 常见的CSS预处理器
**常见的预处理器有哪些呢? 目前使用较多的是三种预处理器:**
**Sass/Scss：**
- 2007年诞生，最早也是最成熟的CSS预处理器，拥有ruby社区的支持，是属于Haml（一种模板系统）的一部分;
- 目前受LESS影响，已经进化到了全面兼容CSS的SCSS;
**Less:**
- 2009年出现，受SASS的影响较大，但又使用CSS的语法，让大部分开发者更容易上手;
- 比起SASS来，可编程功能不够，不过优点是使用方式简单、便捷，兼容CSS，并且已经足够使用；
- 另外反过来也影响了SASS演变到了SCSS的时代；
- 著名的Twitter Bootstrap就是采用LESS做底层语言的，也包括React的UI框架AntDesign。
**Stylus:**
- 2010年产生，来自Node.js社区，主要用来给Node项目进行CSS预处理支持;
- 语法偏向于Python, 使用率相对于Sass/Less少很多
## 认识Less
**什么是Less呢? 我们来看一下官方的介绍:** It's CSS, with just a little more

**Less （Leaner Style Sheets 的缩写） 是一门CSS 扩展语言, 并且兼容CSS。**
- Less增加了很多相比于CSS更好用的特性;
- 比如定义变量、混入、嵌套、计算等等；
- Less最终需要被编译成CSS运行于浏览器中（包括部署到服务器中）；
### less代码的编译
**less代码如何被编译成CSS代码运行呢？**
**方式一：下载Node环境，通过npm包管理下载less工具，使用less工具对代码进行编译；**
**方法二：通过VSCode插件来编译成CSS或者在线编译** https://lesscss.org/less-preview/
方式三：引入CDN的less编译代码，对less进行实时的处理；
方式四：将less编译的js代码下载到本地，执行js代码对less进行编译；

## 使用less

### Less语法一：Less兼容CSS
所以我们可以在Less文件中编写所有的CSS代码；只是将css的扩展名改成了.less结尾而已；
### Less语法二 – 变量（Variables）
在一个大型的网页项目中，我们CSS使用到的某几种属性值往往是特定的
- 比如我们使用到的主题颜色值，那么每次编写类似于#f3c258格式的语法；
- 一方面是记忆不太方便，需要重新编写或者拷贝样式；
- 另一方面如果有一天主题颜色改变，我们需要修改大量的代码；
- 所以，我们可以将常见的颜色或者字体等定义为变量来使用；
**在Less中使用如下的格式来定义变量；**
@变量名: 变量值;
### Less语法三 – 嵌套（Nesting）
**在之前的项目中，当我们需要找到一个内层的元素时，往往需要嵌套很多层的选择器**
**Less提供了选择器的嵌套**
**特殊符号：& 表示当前选择器的父级**
### Less语法四 – 运算（Operations）
**在Less中，算术运算符 +、-、 * 、/ 可以对任何数字、颜色或变量进行运算。**
- 算术运算符在加、减或比较之前会进行单位换算，计算的结果以最左侧操作数的单位类型为准
- 如果单位换算无效或失去意义，则忽略单位；
### Less语法五 – 混合（Mixins）
**在原来的CSS编写过程中，多个选择器中可能会有大量相同的代码**
- 我们希望可以将这些代码进行抽取到一个独立的地方，任何选择器都可以进行复用；
- 在less中提供了混入（Mixins）来帮助我们完成这样的操作；
**混合（Mixin）是一种将一组属性从一个规则集（或混入）到另一个规则集的方法。**

**注意：混入在没有参数的情况下，小括号可以省略，但是不建议这样使用；**

**混入也可以传入变量（暂时了解）**
### Less语法六：映射（Maps）
**混入和映射结合：混入也可以当做一个自定义函数来使用（暂时了解）**

### less其他语法补充
#### Less语法七：extend继承
- 和mixins作用类似，用于复用代码；
- 和mixins相比，继承代码最终会转化成并集选择器；
#### Less语法八：Less内置函数
- Less 内置了多种函数用于转换颜色、处理字符串、算术运算等。
- 内置函数手册： https://less.bootcss.com/functions/
#### Less语法九：作用域（Scope）
- 在查找一个变量时，首先在本地查找变量和混合（mixins）；
- 如果找不到，则从“父”级作用域继承；
#### Less语法十：注释（Comments）
在Less中，块注释和行注释都可以使用；
#### Less语法十一：导入（Importing）
- 导入的方式和CSS的用法是一致的；
- 导入一个 .less 文件，此文件中的所有变量就可以全部使用了；
- 如果导入的文件是 .less 扩展名，则可以将扩展名省略掉；

## 认识Sass和Scss
**事实上，最初Sass 是Haml的一部分，Haml 是一种模板系统，由 Ruby 开发者设计和开发。**
**所以，Sass的语法使用的是类似于Ruby的语法，没有花括号，没有分号，具有严格的缩进；**

**我们会发现它的语法和CSS区别很大，后来官方推出了全新的语法SCSS，意思是Sassy CSS，他是完全兼容CSS的。**

**目前在前端学习SCSS直接学习SCSS即可：**
- SCSS的语法也包括变量、嵌套、混入、函数、操作符、作用域等；
- 通常也包括更为强大的控制语句、更灵活的函数、插值语法等；
- 大家可以根据之前学习的less语法来学习一些SCS语法；
-  https://sass-lang.com/guide


# CSS中的单位
前面编写的CSS中，我们经常会使用px来表示一个长度（大小），比如font-size设置为18px，width设置为100px。
**px是一个长度（length）单位，事实上CSS中还有非常多的长度单位。**
**整体可以分成两类：**
- 绝对长度单位（Absolute length units）；
- 相对长度单位（Relative length units）；
## CSS中的绝对单位（ Absolute length units ）
**绝对单位：**
- 它们与其他任何东西都没有关系，通常被认为总是相同的大小。
- 这些值中的大多数在用于打印时比用于屏幕输出时更有用，例如，我们通常不会在屏幕上使用cm。
- 惟一一个经常使用的值，就是px(像素)。
| 绝对单位 | 名称 | 等价换算            |
| -------- | ---- | ------------------- |
| cm       | 厘米 | 1cm = 96px/2.54     |
|mm|毫米| 1mm = 1/10th of 1cm |
|Q|四分之一毫米| 1Q = 1/40th of 1cm |
|in|英寸| 1in = 2.54cm = 96px |
|pc|十二点活字| 1pc = 1/16th of 1in |
|pt|点| 1pt = 1/72th of 1in |
|px|像素|1px = 1/96th of 1in|

## CSS中的相对单位（ Relative length units ）
**相对长度单位**
- 相对长度单位相对于其他一些东西；
- 比如父元素的字体大小，或者视图端口的大小；
- 使用相对单位的好处是，经过一些仔细的规划，您可以使文本或其他元素的大小与页面上的其他内容相对应；
| 相对单位 | 相对于                                                                                         |
| -------- | ---------------------------------------------------------------------------------------------- |
| em       | 在 font-size 中使用是相对于父元素的字体大小，在其 他属性中使用是相对于自身的字体大小，如 width |
| ex       | 字符“x”的高度                                                                                  |
| ch       | 数字“0”的宽度                                                                                  |
| rem      | 根元素的字体大小                                                                               |
| lh       | 元素的line-height                                                                              |
| vw       | 视窗宽度的1%                                                                                   |
|vh|视窗高度的1%|

## 当我们聊pixel时，到底在聊些什么？
前面我们已经一直在使用px单位了，px是pixel单词的缩写，翻译为像素。
**那么像素到底是什么呢？**
- 像素是影响显示的基本单位。（比如屏幕上看到的画面、一幅图片）；
- pix是英语单词picture的常用简写，加上英语单词“元素”element，就得到pixel；
- “像素”表示“画像元素”之意，有时亦被称为pel（picture element）；
### 像素的不同分类
但是这个100个pixel到底是多少呢？
我们确实可以在屏幕上看到一个大小，但是这个大小代表的真实含义是什么呢？
我们经常说一个电脑的分辨率、手机的分辨率，这个CSS当中的像素又是什么关系呢？
**这里我们要深入到不同的像素概念中，来理解CSS中的pixel到底代表什么含义。**
**像素单位常见的有三种像素名称：**
- 设备像素（也称之为物理像素）；
- 设备独立像素（也称之为逻辑像素）；
- CSS像素；
### 物理像素和逻辑像素
**设备像素，也叫物理像素。**
- 设备像素指的是显示器上的真实像素，每个像素的大小是屏幕固有的属性，屏幕出厂以后就不会改变了；
- 我们在购买显示器或者手机的时候，提到的设备分辨率就是设备像素的大小；
- 比如iPhone X的分辨率 1125x2436，指的就是设备像素；
**设备独立像素，也叫逻辑像素。**
- 如果面向开发者我们使用设备像素显示一个100px的宽度，那么在不同屏幕上显示效果会是不同的；
- 开发者针对不同的屏幕很难进行较好的适配，编写程序必须了解用户的分辨率来进行开发；
- 所以在设备像素之上，操作系统为开发者进行抽象，提供了逻辑像素的概念；
- 比如你购买了一台显示器，在操作系统上是以1920x1080设置的显示分辨率，那么无论你购买的是2k、4k的显示器，对于开发者来说，都是 1920x1080的大小。
**CSS像素**
CSS中我们经常使用的单位也是pixel，它在默认情况下等同于设备独立像素（也就是逻辑像素）；毕竟逻辑像素才是面向我们开发者的
**我们可以通过JavaScript中的screen.width和screen.height获取到电脑的逻辑分辨率**

### DPR、PPI
**DPR：device pixel ratio**
- 2010年，iPhone4问世，不仅仅带来了移动互联网，还带来了Retina屏幕；
- Retina屏幕翻译为视网膜显示屏，可以为用户带来更好的显示；
- 在Retina屏幕中，一个逻辑像素在长度上对应两个物理像素，这个比例称之为设备像素比（device pixel ratio）；
- 我们可以通过window.devicePixelRatio获取到当前屏幕上的DPR值；
**PPI（了解）：每英寸像素（英语：Pixels Per Inch，缩写：PPI）**
- 通常用来表示一个打印图像或者显示器上像素的密度；
- 前面我们提过1英寸=2.54厘米，在工业领域被广泛应用；


# CSS颜色的表示方法

**1. 颜色关键字（color keywords）：**
是不区分大小写的标识符，它表示一个具体的颜色；可以表示哪些颜色呢？
https://developer.mozilla.org/zh-CN/docs/Web/CSS/color_value#%E8%AF%AD%E6%B3%95

**2. RGB颜色：**
RGB是一种色彩空间，通过R（red，红色）、G（green，绿色）、B（blue，蓝色）三原色来组成了不同的颜色；也就是通过调整这三个颜色不同的比例，可以组合成其他的颜色；RGB各个原色的取值范围是 0~255；

## RGB的表示方法
RGB颜色可以通过以#为前缀的十六进制字符和函数（rgb()、rgba()）标记表示。

**方式一：十六进制符号：#RRGGBB\[AA\]**
R（红）、G（绿）、B （蓝）和A （alpha）是十六进制字符（0–9、A–F）；A是可选的。

**方式二：十六进制符号：#RGB\[A\]**
R（红）、G（绿）、B （蓝）和A （alpha）是十六进制字符（0–9、A–F）；
三位数符号（#RGB）是六位数形式（#RRGGBB）的减缩版。
四位数符号（#RGBA）是八位数形式（#RRGGBBAA）的减缩版。

**方式三：函数符： rgb\[a\](R, G, B\[, A\])**
R（红）、G（绿）、B （蓝）可以是（数字），或者（百分比），255相当于100%。
A（alpha）可以是0到1之间的数字，或者百分比，数字1相当于100%（完全不透明）。

# 边框的形状
border主要是用来给盒子增加边框的, 但是在开发中我们也可以利用边框的特性来实现一些形状。
利用border或者CSS的特性我们可以做出很多图形:  https://css-tricks.com/the-shapes-of-css/#top-of-site

# Web字体
在之前我们有设置过页面使用的字体: font-family
- 我们需要提供一个或多个字体种类名称，浏览器会在列表中搜寻，直到找到它所运行的系统上可用的字体。
- 这样的方式完全没有问题，但是对于传统的web开发人员来说，字体选择是有限的;
- 这就是所谓的 Web-safe 字体;
- 并且这种默认可选的字体并不能进行一些定制化的需求;
## Web fonts的工作原理
首先, 我们需要通过一些渠道获取到希望使用的字体(不是开发来做的事情):
- 对于某些收费的字体, 我们需要获取到对应的授权;
- 对于某些公司定制的字体, 需要设计人员来设计;
- 对于某些免费的字体, 我们需要获取到对应的字体文件;
其次, 在我们的CSS代码当中使用该字体(重要)
最后, 在部署静态资源时, 将HTML/CSS/JavaScript/Font一起部署在静态服务器中
**用户的角度:**.
- 浏览器一个网页时, 因为代码中有引入字体文件, 字体文件会被一起下载下来;
- 浏览器会根据使用的字体在下载的字体文件中查找、解析、使用对应的字体；
- 在浏览器中使用对应的字体显示内容；
## 使用Web Fonts
第一步：在字体天下网站下载一个字体  https://www.fonts.net.cn/fonts-zh-1.html  
默认下载下来的是ttf文件；
第二步：使用字体；
**使用过程如下：**
1. 将字体放到对应的目录中
2. 通过@font-face来引入字体, 并且设置格式
3. 使用字体
**注意: @font-face 用于加载一个自定义的字体;**

## web-fonts的兼容性
我们刚才使用的字体文件是 .ttf, 它是TrueType字体；在开发中某些浏览器可能不支持该字体, 所以为了浏 览器的兼容性问题, 我们需要有对应其他格式的字体
**TrueType字体：拓展名是 .ttf**
- OpenType/TrueType字体：拓展名是 .ttf、.otf， 建立在TrueType字体之上
- Embedded OpenType字体：拓展名是 .eot， OpenType字体的压缩版
- SVG字体：拓展名是 .svg、 .svgz
- WOFF表示Web Open Font Format web开放字体： 拓展名是 .woff，建立在TrueType字体之上
这里我们提供一个网站来生产对应的字体文件:  https://font.qqe2.com/# 暂时可用

### web fonts兼容性写法
如果我们具备很强的兼容性, 那么可以如下格式编写:
![[web font兼容性写法.png]]
**这被称为"bulletproof @font-face syntax（刀枪不入的@font-face语法）“:**
这是 Paul Irish早期的一篇文章提及后@font-face开始流行起来 (Bulletproof @font-face Syntax)。

**src用于指定字体资源：**
- url指定资源的路径
- format用于帮助浏览器快速识别字体的格式;

# 认识字体图标
思考：字体可以设计成各式各样的形状，那么能不能把字体直接设计成图标的样子呢？  
当然可以，这个就叫做字体图标。
**字体图标的好处：**
- 放大不会失真
- 可以任意切换颜色
- 用到很多个图标时，文件相对图片较小
**字体图标的使用：**
- 登录阿里icons（ https://www.iconfont.cn/ ）
- 下载代码，并且拷贝到项目中
- 将字体文件和默认的css文件导入到项目中
## 字体图标的使用
**字体图标的使用步骤:**
- 第一步: 通过link引入iconfont.css文件
- 第二步: 使用字体图标
**使用字体图标常见的有两种方式**
- 方式一: 通过对应字体图标的Unicode来显示代码;
- 方式二: 利用已经编写好的class, 直接使用即可;

# 认识精灵图 CSS Sprite
## 什么是CSS Sprite
是一种CSS图像合成技术，将各种小图片合并到一张图片上，然后利用CSS的背景定位来显示对应的图片部分；有人翻译为：CSS雪碧、CSS精灵

## 使用CSS Sprite的好处
- 减少网页的http请求数量，加快网页响应速度，减轻服务器压力
- 减小图片总大小
- 解决了图片命名的困扰，只需要针对一张集合的图片命名

## Sprite图片制作（雪碧图、精灵图）
- 方法1：Photoshop, 设计人员提供
- 方法2： https://www.toptal.com/developers/css/sprite-generator

## 精灵图的使用
**精灵图如何使用呢?**
精灵图的原理是通过只显示图片的很小一部分来展示的;
**通常使用背景:**
1. 设置对应元素的宽度和高度
2. 设置精灵图作为背景图片
3. 调整背景图片的位置来展示
**如何获取精灵图的位置:** http://www.spritecow.com/

# cusor
**cursor可以设置鼠标指针（光标）在元素上面时的显示样式**

**cursor常见的设值有:**
- auto：浏览器根据上下文决定指针的显示样式，比如根据文本和非文本切换指针样式
- default：由操作系统决定，一般就是一个小箭头
- pointer：一只小手，鼠标指针挪动到链接上面默认就是这个样式
- text：一条竖线，鼠标指针挪动到文本输入框上面默认就是这个样式
- none：没有任何指针显示在元素上面


# vertical-align
## 深入理解vertical-align – line boxes
**官方文档的翻译：vertical-align会影响 行内块级元素 在一个 行盒 中垂直方向的位置**
**思考：一个div没有设置高度的时候，会不会有高度？**
- 没有内容，没有高度
- 有内容，内容撑起来高度
**但是内容撑起来高度的本质是什么呢？**
- 内容有行高（line-height），撑起来了div的高度
**行高为什么可以撑起div的高度？**
- 这是因为line boxes的存在，并且line-boxes有一个特性，包裹每行的inline level
- 而其中的文字是有行高的，必须将整个行高包裹进去，才算包裹这个line-level
**那么，进一步思考：**
- 情况一：只有文字时，line boxes如何包裹内容？
- 情况二：有图片，有文字时，line-boxes如何包裹内容？
- 情况三：有图片，有文字，有inline-block（比图片要大）如何包裹内容？
- 情况四：有图片，有文字，有inline-block（比图片要大）而且设置了margin-bottom，如何包裹内容？
- 情况五：有图片、文字、inline-block（比图片要大）而且设置了margin-bottom并且有文字，如何包裹内容？
**结论**：line-boxes一定会想办法包裹住当前行中所有的内容。
## vertical-align的baseline
为什么对齐方式千奇百怪呢？
你认为的千奇百怪，其实有它的内在规律;答案就是baseline对齐
官方vertical-align的默认值：没错，就是baseline
**但是baseline都是谁呢？**
- 文本的baseline是字母x的下方
- Inline-block默认的baseline是margin-bottom的底部（没有，就是盒子的底部）
- Inline-block默认的baseline是margin-bottom的底部（没有，就是盒子的底部）
## vertical-align的其他值
**不同的取值:**
- baseline(默认值)：基线对齐（你得先明白什么是基线）
- top：把行内级盒子的顶部跟line boxes顶部对齐
- middle：行内级盒子的中心点与父盒基线加上x-height一半的线对齐
- bottom：把行内级盒子的底部跟line box底部对齐
- \<percentage\>：把行内级盒子提升或者下降一段距离（距离相对于line-height计算\元素高度）， 0%意味着同baseline一 样
- \<percentage\>：把行内级盒子提升或者下降一段距离，0cm意味着同baseline一样
解决图片下边缘的间隙方法:
- 方法一: 设置成top/middle/bottom
- 方法二: 将图片设置为block元素



# CSS属性 - transform
**CSS transform属性允许你旋转，缩放，倾斜或平移给定元素。**(Transform是形变的意思，transformer就是变形金刚)

**常见的函数transform function有：**
- 平移：translate(x, y)
- 缩放：scale(x, y)
- 旋转：rotate(deg)
- 倾斜：skew(deg, deg)
通过上面的几个函数，我们可以改变某个元素的形变

## 位移 - translate
**平移：translate(x, y)**
**值个数:**
- 一个值时，设置x轴上的位移
- 二个值时，设置x轴和y轴上的位移
**值类型：**
- 数字：100px
- 百分比：参照元素本身（ refer to the size of bounding box ）

## 缩放 - scale
**缩放：scale(x, y)**
**值个数:**
- 一个值时，设置x轴上的缩放
- 二个值时，设置x轴和y轴上的缩放
**值类型：**
- 数字：
  - 1：保持不变
  - 2：放大一倍
  - 0.5：缩小一半
- 百分比：不支持百分比

## transform-origin
**transform-origin：变形的原点**
**一个值：** 设置x轴的原点
**两个值：** 设置x轴和y轴的原点
必须是\<length\>，\<percentage\>，或 left, center, right, top, bottom关键字中的一个
- left, center, right, top, bottom关键字
- length：从左上角开始计算
- 百分比：参考元素本身大小

## 缩放 - rotat
**旋转：rotate(deg)**
**值个数:** 一个值时，表示旋转的角度
**值类型：**
- deg：旋转的角度
- 正数为顺时针
- 负数为逆时针
**注意：旋转的原点受transform-origin的影响**

## 倾斜 - skew
**旋转：skew(x, y)**
**值个数:**
- 一个值时，表示x轴上的倾斜
- 二个值时，表示x轴和y轴上的倾斜
**值类型：**
- deg：旋转的角度
- 正数为顺时针
- 负数为逆时针
**注意：旋转的原点受transform-origin的影响**



# 过渡动画 - transition

**transition CSS 属性是 transition-property，transition-duration，transition-timing-function 和 transition-delay 的 一个简写属性。**
- transition-property：指定应用过渡属性的名称
  - 可以写all表示所有可动画的属性
  - 属性是否支持动画查看文档
- transition-duration：指定过渡动画所需的时间
  - 单位可以是秒（s）或毫秒（ms）
- transition-timing-function：指定动画的变化曲线
  - https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-timing-function
- transition-delay：指定过渡动画执行之前的等待时间

# 关键帧动画
**之前我们学习了transition来进行过渡动画，但是过渡动画只能控制首尾两个值：**
- 从关键帧动画的角度相当于只是定义了两帧的状态：第一帧和最后一帧。
- 如果我们希望可以有更多状态的变化，可以直接使用关键帧动画。
**关键帧动画使用@keyframes来定义多个变化状态，并且使用animation-name来声明匹配：**
1. 使用 @keyframes创建一个规则
2. @keyframes中使用百分比定义各个阶段的样式
3. 通过animation将动画添加到属性上
**另外，也可以使用from和to关键字：**
- from相当于0%
- to相当于100%

# animation属性
**CSS animation 属性是 animation-name，animation-duration, animation-timing-function，animation-delay，animation-iteration-count，animation-direction，animation-fill-mode 和 animation-play-state 属性的一个简写属性形式。**
- animation-name：指定执行哪一个关键帧动画
- animation-duration：指定动画的持续时
- animation-timing-function：指定动画的变化曲线
- animation-delay：指定延迟执行的时间
- animation-iteration-count：指定动画执行的次数，执行infinite表示无限动画
- animation-direction：指定方向，常用值normal和reverse
- animation-fill-mode：执行动画最后保留哪一个值
  - none：回到没有执行动画的位置
  - forwards：动画最后一帧的位置
  - backwards：动画第一帧的位
- animation-play-state：指定动画运行或者暂停（在JavaScript中使用，用于暂停动画）
- 
